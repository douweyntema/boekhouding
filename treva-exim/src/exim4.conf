###########################
# MAIN CONFIG
###########################

exim_path = /usr/sbin/exim4

timeout_frozen_after = 2w

daemon_smtp_ports = 25 : 587
local_interfaces = <; 0.0.0.0; ::0

local_from_check = false
local_sender_retain = true
untrusted_set_sender = *

smtp_accept_max = 100
smtp_accept_max_per_host = 5

acl_smtp_data = acl_check_data
acl_smtp_rcpt = acl_check_rcpt
av_scanner = clamd:/var/run/clamav/clamd.ctl
message_size_limit = 100M
spamd_address = 127.0.0.1 783

tls_advertise_hosts = *
tls_certificate = /etc/ssl/certs/treva.pem
tls_privatekey = /etc/ssl/private/treva.pem

host_lookup = *
rfc1413_hosts = 
smtp_connect_backlog = 50

domainlist local_domains = /etc/exim4/database/local_domains
domainlist relay_domains = /etc/exim4/database/relay_domains
domainlist valid_domains = +local_domains : +relay_domains

###########################
# ACLs
###########################

begin acl

acl_check_rcpt:
  # The following section of the ACL is concerned with local parts that contain
  # certain non-alphanumeric characters. Dots in unusual places are
  # handled by this ACL as well.
  #
  # Non-alphanumeric characters other than dots are rarely found in genuine
  # local parts, but are often tried by people looking to circumvent
  # relaying restrictions. Therefore, although they are valid in local
  # parts, these rules disallow certain non-alphanumeric characters, as
  # a precaution.
  #
  # Empty components (two dots in a row) are not valid in RFC 2822, but Exim
  # allows them because they have been encountered. (Consider local parts
  # constructed as "firstinitial.secondinitial.familyname" when applied to
  # a name without a second initial.) However, a local part starting
  # with a dot or containing /../ can cause trouble if it is used as part of a
  # file name (e.g. for a mailing list). This is also true for local parts that
  # contain slashes. A pipe symbol can also be troublesome if the local part is
  # incorporated unthinkingly into a shell command line.
  #
  # Two different rules are used. The first one has a quite strict
  # default, and is applied to messages that are addressed to one of the
  # local domains handled by this host.
  # If you have local accounts that include strange characters, you can
  # use the macro provided to change the ACL range or to disable the
  # check completely.
  deny
    domains = +valid_domains
    local_parts = ^[.] : ^.*[@%!/|\'`#&?]
    message = restricted characters in address

  # The second rule applies to all other domains, and its default is
  # considerably less strict.
  deny
    domains = !+valid_domains
    local_parts = ^[./|] : ^.*[@%!\'`#&?] : ^.*/\\.\\./
    message = restricted characters in address

  # Accept if the source is local SMTP (i.e. not over TCP/IP). We do this by
  # testing for an empty sending host field.
  accept
    hosts = :
    control = submission

  # Accept if the message arrived over an authenticated connection, from
  # any host. Again, these messages are usually from MUAs, so recipient
  # verification is omitted.
  accept
    authenticated = *
    control = submission/sender_retain

  # Accept if the address is in a local domain, but only if the recipient can
  # be verified. Otherwise deny.
  accept
    domains = +valid_domains
    verify = recipient

  deny
    domains = +valid_domains
    message = unknown user

  # Reaching the end of the ACL causes a "deny", but we might as well give
  # an explicit message.
  deny
    message = relay not permitted

acl_check_data:
  # check for virusses
  warn
    malware = true
    set acl_m1 = true

  # check for spam
  warn
    spam = nobody
    set acl_m2 = true

  # accept otherwise
  accept

###########################
# ROUTERS
###########################

begin routers

local_smtp:
  debug_print = "R: local_smtp for $local_part@$domain"
  driver = dnslookup
  condition = ${if eq{$sender_host_address}{}}
  errors_to =
  self = send
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8 : 192.168.0.0/16 :  172.16.0.0/12 : 10.0.0.0/8 : 169.254.0.0/16
  transport = remote_smtp
  no_more

authenticated_smtp:
  debug_print = "R: authenticated_smtp for $local_part@$domain"
  driver = dnslookup
  condition = $authenticated_id
  errors_to = $authenticated_id
  self = send
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8 : 192.168.0.0/16 :  172.16.0.0/12 : 10.0.0.0/8 : 169.254.0.0/16
  transport = remote_smtp
  no_more


external_smtp:
  debug_print = "R: external_smtp for $local_part@$domain"
  driver = dnslookup
  domains = ! +valid_domains
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8 : 192.168.0.0/16 :  172.16.0.0/12 : 10.0.0.0/8 : 169.254.0.0/16
  transport = remote_smtp
  no_more


relay:
  debug_print = "R: relay_valid for $local_part@$domain"
  driver = manualroute
  domains = +relay_domains
  condition = ${lookup{$local_part@$domain}lsearch{/etc/exim4/database/relay_addresses}}
  route_data = ${lookup{$local_part@$domain}lsearch{/etc/exim4/database/relay_addresses}}
  errors_to = ${if or {{eq {$acl_m1}{true}}{eq {acl_m2}{true}}}{}{$return_path}}
  transport = remote_smtp

relay_catchall:
  debug_print = "R: relay_valid for $local_part@$domain"
  driver = manualroute
  domains = +relay_domains
  condition = ${lookup{@$domain}lsearch{/etc/exim4/database/relay_addresses}}
  route_data = ${lookup{@$domain}lsearch{/etc/exim4/database/relay_addresses}}
  errors_to = ${if or {{eq {$acl_m1}{true}}{eq {acl_m2}{true}}}{}{$return_path}}
  transport = remote_smtp


local_alias:
  debug_print = "R: local_alias for $local_part@$domain"
  driver = redirect
  domains = +local_domains
  forbid_file
  forbid_include
  forbid_pipe
  one_time
  data = ${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_aliases}}

local_catchall_alias:
  debug_print = "R: local_catchall_alias for $local_part@$domain"
  driver = redirect
  domains = +local_domains
  condition = ${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}{false}{true}}
  forbid_file
  forbid_include
  forbid_pipe
  one_time
  data = ${lookup{@$domain}lsearch{/etc/exim4/database/local_aliases}}


local_mailbox_virus_drop:
  debug_print = "R: local_mailbox_virus_drop for $local_part@$domain"
  driver = accept
  domains = +local_domains
  condition = ${if and {{eq {$acl_m1}{true}}{eq {${extract{3}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}}}}{drop}}}}
  transport = blackhole

local_mailbox_virus_folder:
  debug_print = "R: local_mailbox_virus_folder for $local_part@$domain"
  driver = accept
  domains = +local_domains
  condition = ${if and {{eq {$acl_m1}{true}}{eq {${extract{3}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}}}}{folder}}}}
  address_data = ${extract{4}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}}}
  errors_to =
  transport = dovecot_folder

local_mailbox_spam_drop:
  debug_print = "R: local_mailbox_spam_drop for $local_part@$domain"
  driver = accept
  domains = +local_domains
  condition = ${if and {{eq {$acl_m2}{true}}{eq {${extract{1}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}}}}{drop}}}}
  transport = blackhole

local_mailbox_spam_folder:
  debug_print = "R: local_mailbox_spam_folder for $local_part@$domain"
  driver = accept
  domains = +local_domains
  condition = ${if and {{eq {$acl_m2}{true}}{eq {${extract{1}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}}}}{folder}}}}
  address_data = ${extract{2}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}}}
  errors_to =
  transport = dovecot_folder

local_mailbox:
  debug_print = "R: local_mailbox for $local_part@$domain"
  driver = accept
  domains = +local_domains
  condition = ${lookup{$local_part@$domain}lsearch{/etc/exim4/database/local_mailboxes}}
  transport = dovecot

###########################
# TRANSPORTS
###########################

begin transports

remote_smtp:
  debug_print = "T: remote_smtp for $local_part@$domain"
  driver = smtp

blackhole:
  debug_print = "T: blackhole for $local_part@$domain"
  driver = appendfile
  file = /dev/null

dovecot:
  driver = pipe
  command = /usr/lib/dovecot/deliver -d $local_part@$domain -f $sender_address
  message_prefix =
  message_suffix =
  delivery_date_add
  envelope_to_add
  return_path_add
  user = mailbox
  group = mailbox
  temp_errors = 75

dovecot_folder:
  driver = pipe
  command = /usr/lib/dovecot/deliver -d $local_part@$domain -f $sender_address -m $address_data
  message_prefix =
  message_suffix =
  delivery_date_add
  envelope_to_add
  return_path_add
  user = mailbox
  group = mailbox
  temp_errors = 75

###########################
# RETRY
###########################

begin retry

# Domain               Error       Retries
# ------               -----       -------

*                      *           F,2h,15m; G,16h,1h,1.5; F,4d,6h

###########################
# REWRITE
###########################

begin rewrite

###########################
# AUTHENTICATION
###########################

begin authenticators

plain:
  driver = plaintext
  public_name = PLAIN
  server_prompts = :
  server_condition = ${if eq{${rfc2047d:${lookup{$auth2}lsearch{/etc/exim4/database/auth_passwords}}}}{$auth3}}
  server_set_id=$auth2

login:
  driver = plaintext
  public_name = LOGIN
  server_prompts = <; Username: ; Password:
  server_condition = ${if eq{${rfc2047d:${lookup{$auth1}lsearch{/etc/exim4/database/auth_passwords}}}}{$auth2}}
  server_set_id=$auth1

cram_md5:
  driver = cram_md5
  public_name = CRAM-MD5
  server_secret = ${rfc2047d:${lookup{$auth1}lsearch{/etc/exim4/database/auth_passwords}}}
  server_set_id=$auth1
